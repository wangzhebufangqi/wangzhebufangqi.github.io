<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>layout:     post
title:      lxml.etree学习
subtitle:   初探etree
date:       2020-12-11
author:     wangzhebufangqi
header-img: img/post-bg-201208.png
catalog: true
tags:
    - python
    - lxml
    - etree
    - 爬虫
</code></pre></div></div>

<p>导入lxml.etree的一种常见的方式：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">lxml</span> <span class="kn">import</span> <span class="n">etree</span>
</code></pre></div></div>

<h1 id="the-element-class">The Element class</h1>

<p>元素（Element）是ElementTree API的主要容器对象。 大多数XML树功能都是通过此类访问的。 元素可以通过<code class="language-plaintext highlighter-rouge">Element</code>方法轻松创建：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">Element</span><span class="p">(</span><span class="s">"root"</span><span class="p">)</span>
</code></pre></div></div>

<p>元素的XML标签名称可通过tag属性访问：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">tag</span><span class="p">)</span>
<span class="n">root</span>
</code></pre></div></div>

<p>元素以XML树结构组织。 要创建子元素并将其添加到父元素，可以使用append方法：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">root</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="n">etree</span><span class="p">.</span><span class="n">Element</span><span class="p">(</span><span class="s">"child1"</span><span class="p">)</span> <span class="p">)</span>
</code></pre></div></div>

<p>但是，有一种更短，更有效的方法来做到这一点：<code class="language-plaintext highlighter-rouge">SubElement</code>方法。 它接受与<code class="language-plaintext highlighter-rouge">Element</code>方法相同的参数，但另外需要将父元素作为第一个参数：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">child2</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">"child2"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">child3</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">"child3"</span><span class="p">)</span>
</code></pre></div></div>

<p>要查看这确实是XML，可以序列化创建的树：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="bp">True</span><span class="p">).</span><span class="n">decode</span><span class="p">())</span>
<span class="o">&lt;</span><span class="n">root</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">child1</span><span class="o">/&gt;</span>
  <span class="o">&lt;</span><span class="n">child2</span><span class="o">/&gt;</span>
  <span class="o">&lt;</span><span class="n">child3</span><span class="o">/&gt;</span>
<span class="o">&lt;/</span><span class="n">root</span><span class="o">&gt;</span>
</code></pre></div></div>

<h2 id="elements-are-lists">Elements are lists</h2>

<p>为了使对这些子元素的访问变得简单而直接，元素尽可能地模仿了普通Python列表的行为：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">child</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">tag</span><span class="p">)</span>
<span class="n">child1</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>
<span class="mi">3</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">root</span><span class="p">.</span><span class="n">index</span><span class="p">(</span><span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="c1"># lxml.etree only!
</span><span class="mi">1</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">children</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
<span class="p">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">tag</span><span class="p">)</span>
<span class="p">...</span>
<span class="n">child1</span>
<span class="n">child2</span>
<span class="n">child3</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">root</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">etree</span><span class="p">.</span><span class="n">Element</span><span class="p">(</span><span class="s">"child0"</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">start</span> <span class="o">=</span> <span class="n">root</span><span class="p">[:</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">end</span>   <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">:]</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">start</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tag</span><span class="p">)</span>
<span class="n">child0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">end</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tag</span><span class="p">)</span>
<span class="n">child3</span>
</code></pre></div></div>

<p>使用<code class="language-plaintext highlighter-rouge">len(element)</code>方法判断是否有孩子：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="p">.</span><span class="n">iselement</span><span class="p">(</span><span class="n">root</span><span class="p">))</span>  <span class="c1"># test if it's some kind of Element
</span><span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">root</span><span class="p">):</span>                 <span class="c1"># test if it has children
</span><span class="p">...</span>     <span class="k">print</span><span class="p">(</span><span class="s">"The root element has children"</span><span class="p">)</span>
<span class="p">...</span>
<span class="n">The</span> <span class="n">root</span> <span class="n">element</span> <span class="n">has</span> <span class="n">children</span>
</code></pre></div></div>

<p>lxml（在2.0及更高版本中）中Elements的行为与列表的行为和原始ElementTree（在1.3版或Python 2.7 / 3.2之前的版本）的行为不同：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
<span class="p">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">tag</span><span class="p">)</span>
<span class="p">...</span>
<span class="n">child0</span>
<span class="n">child1</span>
<span class="n">child2</span>
<span class="n">child3</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">root</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>  <span class="c1"># this moves the element in lxml.etree!
</span><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="n">root</span><span class="p">:</span>
<span class="p">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">child</span><span class="p">.</span><span class="n">tag</span><span class="p">)</span>
<span class="p">...</span>
<span class="n">child3</span>
<span class="n">child1</span>
<span class="n">child2</span>
</code></pre></div></div>

<p>在该示例中，最后一个元素被移动到另一个位置，而不是被复制，即，当将其放置在另一个位置时，它会自动从其先前位置中删除。 在列表中，对象可以同时出现在多个位置，上述分配只是将项目引用复制到第一个位置，因此两个对象都包含完全相同的项目：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">l</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">l</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">l</span>
<span class="p">[</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">]</span>
</code></pre></div></div>

<p>这种差异的好处是lxml.etree中的元素始终只有一个父对象，可以通过getparent方法查询。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">root</span> <span class="ow">is</span> <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getparent</span><span class="p">()</span>  <span class="c1"># lxml.etree only!
</span><span class="bp">True</span>
</code></pre></div></div>

<p>如果要将元素复制到lxml.etree中的其他位置，请考虑使用Python标准库中的copy模块创建独立的深层副本：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">copy</span> <span class="kn">import</span> <span class="n">deepcopy</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">element</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">Element</span><span class="p">(</span><span class="s">"neu"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">element</span><span class="p">.</span><span class="n">append</span><span class="p">(</span> <span class="n">deepcopy</span><span class="p">(</span><span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">element</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">tag</span><span class="p">)</span>
<span class="n">child1</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">([</span> <span class="n">c</span><span class="p">.</span><span class="n">tag</span> <span class="k">for</span> <span class="n">c</span> <span class="ow">in</span> <span class="n">root</span> <span class="p">])</span>
<span class="p">[</span><span class="s">'child3'</span><span class="p">,</span> <span class="s">'child1'</span><span class="p">,</span> <span class="s">'child2'</span><span class="p">]</span>
</code></pre></div></div>

<p>元素的兄弟姐妹（或邻居）作为下一个和上一个元素访问：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="ow">is</span> <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">getprevious</span><span class="p">()</span> <span class="c1"># lxml.etree only!
</span><span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">root</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="ow">is</span> <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getnext</span><span class="p">()</span> <span class="c1"># lxml.etree only!
</span><span class="bp">True</span>
</code></pre></div></div>

<h2 id="elements-carry-attributes-as-a-dict">Elements carry attributes as a dict</h2>

<p>XML元素支持属性。 可以直接在<code class="language-plaintext highlighter-rouge">Element</code>F方法中创建它们：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">Element</span><span class="p">(</span><span class="s">"root"</span><span class="p">,</span> <span class="n">interesting</span><span class="o">=</span><span class="s">"totally"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">).</span><span class="n">decode</span><span class="p">()</span>
<span class="s">'&lt;root interesting="totally"/&gt;
</span></code></pre></div></div>

<p>属性只是无序的名称/值对，因此处理元素的一种非常方便的方法是通过元素的类似字典的接口：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"interesting"</span><span class="p">))</span>
<span class="n">totally</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"hello"</span><span class="p">))</span>
<span class="bp">None</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">root</span><span class="p">.</span><span class="nb">set</span><span class="p">(</span><span class="s">"hello"</span><span class="p">,</span><span class="s">"Huhu"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"hello"</span><span class="p">))</span>
<span class="n">Huhu</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">).</span><span class="n">decode</span><span class="p">()</span>
<span class="s">'&lt;root interesting="totally" hello="Huhu"/&gt;'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">keys</span><span class="p">())</span>
<span class="p">[</span><span class="s">'hello'</span><span class="p">,</span> <span class="s">'interesting'</span><span class="p">]</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span><span class="n">value</span> <span class="ow">in</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">items</span><span class="p">()):</span>
<span class="p">...</span>     <span class="k">print</span><span class="p">(</span><span class="s">'%s = %r'</span> <span class="o">%</span> <span class="p">(</span><span class="n">name</span><span class="p">,</span><span class="n">value</span><span class="p">))</span>
<span class="p">...</span>
<span class="n">hello</span> <span class="o">=</span> <span class="s">'Huhu'</span>
<span class="n">interesting</span> <span class="o">=</span> <span class="s">'totally'</span>
</code></pre></div></div>

<p>进行项目查找或有其他原因获得“真实”字典式对象的情况，例如 为了传递它，可以使用<code class="language-plaintext highlighter-rouge">attrib</code>属性：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">attributes</span> <span class="o">=</span> <span class="n">root</span><span class="p">.</span><span class="n">attrib</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">attributes</span><span class="p">[</span><span class="s">"interesting"</span><span class="p">])</span>
<span class="n">totally</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">attributes</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"no-such-attribute"</span><span class="p">))</span>
<span class="bp">None</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">attributes</span><span class="p">[</span><span class="s">"hello"</span><span class="p">]</span> <span class="o">=</span> <span class="s">"Guten Tag"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">attributes</span><span class="p">[</span><span class="s">"hello"</span><span class="p">])</span>
<span class="n">Guten</span> <span class="n">Tag</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="s">"hello"</span><span class="p">))</span>
<span class="n">Guten</span> <span class="n">Tag</span>
</code></pre></div></div>

<p>请注意，<code class="language-plaintext highlighter-rouge">attrib</code>是元素本身支持的类似dict的对象。 这意味着对元素的任何更改都会反映在属性上，反之亦然。 这也意味着，只要使用其中一个Elements的属性，XML树就会在内存中保持活动状态。 要获得不依赖于XML树的属性的独立快照，请将其复制到dict中：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">d</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">attrib</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">items</span><span class="p">())</span>
<span class="p">[(</span><span class="s">'hello'</span><span class="p">,</span> <span class="s">'Guten Tag'</span><span class="p">),</span> <span class="p">(</span><span class="s">'interesting'</span><span class="p">,</span> <span class="s">'totally'</span><span class="p">)]</span>
</code></pre></div></div>

<h2 id="elements-contain-text">Elements contain text</h2>

<p>元素可以包含文本：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">Element</span><span class="p">(</span><span class="s">"root"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">root</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"TEXT"</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">text</span><span class="p">)</span>
<span class="n">TEXT</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="s">b'&lt;root&gt;TEXT&lt;/root&gt;'</span>
</code></pre></div></div>

<p>在许多XML文档（以数据为中心的文档）中，这是唯一可以找到文本的地方。 它由位于树层次结构最底部的叶子标签封装。</p>

<p>但是，如果XML用于标记的文本文档（如（X）HTML），则文本也可以出现在树中间的不同元素之间：</p>

<div class="language-html highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;html&gt;&lt;body&gt;</span>Hello<span class="nt">&lt;br/&gt;</span>World<span class="nt">&lt;/body&gt;&lt;/html&gt;</span>
</code></pre></div></div>

<p>在这里，&lt;br/&gt;标记被文本包围。 这通常称为文档样式或混合内容XML。 元素通过其<code class="language-plaintext highlighter-rouge">tail</code>属性支持这一点。 它包含直接在元素之后的文本，直到XML树中的下一个元素：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">html</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">Element</span><span class="p">(</span><span class="s">"html"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">body</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">html</span><span class="p">,</span> <span class="s">"body"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">body</span><span class="p">.</span><span class="n">text</span> <span class="o">=</span> <span class="s">"TEXT"</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>
<span class="s">b'&lt;html&gt;&lt;body&gt;TEXT&lt;/body&gt;&lt;/html&gt;'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">br</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">body</span><span class="p">,</span> <span class="s">"br"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>
<span class="s">b'&lt;html&gt;&lt;body&gt;TEXT&lt;br/&gt;&lt;/body&gt;&lt;/html&gt;'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">br</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="s">"TAIL"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>
<span class="s">b'&lt;html&gt;&lt;body&gt;TEXT&lt;br/&gt;TAIL&lt;/body&gt;&lt;/html&gt;'</span>
</code></pre></div></div>

<p><code class="language-plaintext highlighter-rouge">text</code>和<code class="language-plaintext highlighter-rouge">tail</code>这两个属性足以表示XML文档中的任何文本内容。 这样，ElementTree API不需要除Element类之外的任何特殊文本节点，这些节点往往会很常见（您可能从经典DOM API中知道）。</p>

<p>但是，在某些情况下，尾部文本也会成为障碍。 例如，从树中序列化一个元素时，并不总是希望结果中包含其尾部文本（尽管仍然希望其子元素的尾部文本）。 为此，<code class="language-plaintext highlighter-rouge">tostring</code>函数接受关键字参数<code class="language-plaintext highlighter-rouge">with_tail</code>：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">br</span><span class="p">)</span>
<span class="s">b'&lt;br/&gt;TAIL'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">br</span><span class="p">,</span> <span class="n">with_tail</span><span class="o">=</span><span class="bp">False</span><span class="p">)</span> <span class="c1"># lxml.etree only!
</span><span class="s">b'&lt;br/&gt;'</span>
</code></pre></div></div>

<p>如只想读取文本，即没有任何中间标签，则必须以正确的顺序递归连接所有<code class="language-plaintext highlighter-rouge">text</code>和<code class="language-plaintext highlighter-rouge">tail</code>属性。 再次，<code class="language-plaintext highlighter-rouge">tostring</code>函数可以使用此方法关键字：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">html</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">"text"</span><span class="p">)</span>
<span class="s">b'TEXTTAIL'</span>
</code></pre></div></div>

<h2 id="using-xpath-to-find-text">Using XPath to find text</h2>

<p>提取树的文本内容的另一种方法是<code class="language-plaintext highlighter-rouge">xpath</code>，它还允许将单独的文本块提取到列表中：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">html</span><span class="p">.</span><span class="n">xpath</span><span class="p">(</span><span class="s">"string()"</span><span class="p">))</span> <span class="c1"># lxml.etree only!
</span><span class="n">TEXTTAIL</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">html</span><span class="p">.</span><span class="n">xpath</span><span class="p">(</span><span class="s">"//text()"</span><span class="p">))</span> <span class="c1"># lxml.etree only!
</span><span class="p">[</span><span class="s">'TEXT'</span><span class="p">,</span> <span class="s">'TAIL'</span><span class="p">]</span>
</code></pre></div></div>

<p>如果想更频繁地使用它，可以将其包装在一个函数中：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">build_text_list</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">XPath</span><span class="p">(</span><span class="s">"//text()"</span><span class="p">)</span> <span class="c1"># lxml.etree only!
</span><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">build_text_list</span><span class="p">(</span><span class="n">html</span><span class="p">))</span>
<span class="p">[</span><span class="s">'TEXT'</span><span class="p">,</span> <span class="s">'TAIL'</span><span class="p">]</span>
</code></pre></div></div>

<p>请注意，<code class="language-plaintext highlighter-rouge">xpath</code>返回的字符串结果是一个特殊的“智能”对象，它知道其起源。 您可以通过其<code class="language-plaintext highlighter-rouge">getparent</code>方法询问它的来源，就像使用Elements一样：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">texts</span> <span class="o">=</span> <span class="n">build_text_list</span><span class="p">(</span><span class="n">html</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">texts</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
<span class="n">TEXT</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">parent</span> <span class="o">=</span> <span class="n">texts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getparent</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">tag</span><span class="p">)</span>
<span class="n">body</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">texts</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="n">TAIL</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">texts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">getparent</span><span class="p">().</span><span class="n">tag</span><span class="p">)</span>
<span class="n">br</span>
</code></pre></div></div>

<p>还可以确定它是普通文本内容还是尾部文本：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">texts</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">is_text</span><span class="p">)</span>
<span class="bp">True</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">texts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">is_text</span><span class="p">)</span>
<span class="bp">False</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">texts</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">is_tail</span><span class="p">)</span>
<span class="bp">True</span>
</code></pre></div></div>

<p>尽管这对于<code class="language-plaintext highlighter-rouge">text</code>函数的结果有效，但是lxml不会告诉您xpath函数<code class="language-plaintext highlighter-rouge">string</code>或<code class="language-plaintext highlighter-rouge">concat</code>构造的字符串值的来源：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">stringify</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">XPath</span><span class="p">(</span><span class="s">"string()"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">stringify</span><span class="p">(</span><span class="n">html</span><span class="p">))</span>
<span class="n">TEXTTAIL</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">stringify</span><span class="p">(</span><span class="n">html</span><span class="p">).</span><span class="n">getparent</span><span class="p">())</span>
<span class="bp">None</span>
</code></pre></div></div>

<p>注意使用<code class="language-plaintext highlighter-rouge">XPath</code>还是<code class="language-plaintext highlighter-rouge">xpath</code>：前者用在etree后，即etree.Xpath()；后者用在元素（Element）后。</p>

<h2 id="tree-iteration">Tree iteration</h2>

<p>对于上述问题，要递归遍历树并对其元素进行处理，树迭代是一种非常方便的解决方案。 元素为此提供了一个树迭代器。 它按文档顺序生成元素，即，如果将树序列化为XML，则按其标签显示的顺序：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">Element</span><span class="p">(</span><span class="s">"root"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">"child"</span><span class="p">).</span><span class="n">text</span> <span class="o">=</span> <span class="s">"Child 1"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">"child"</span><span class="p">).</span><span class="n">text</span> <span class="o">=</span> <span class="s">"Child 2"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">SubElement</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">"another"</span><span class="p">).</span><span class="n">text</span> <span class="o">=</span> <span class="s">"Child 3"</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="o">&lt;</span><span class="n">root</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">child</span><span class="o">&gt;</span><span class="n">Child</span> <span class="mi">1</span><span class="o">&lt;/</span><span class="n">child</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">child</span><span class="o">&gt;</span><span class="n">Child</span> <span class="mi">2</span><span class="o">&lt;/</span><span class="n">child</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">another</span><span class="o">&gt;</span><span class="n">Child</span> <span class="mi">3</span><span class="o">&lt;/</span><span class="n">another</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">root</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">root</span><span class="p">.</span><span class="nb">iter</span><span class="p">():</span>
<span class="p">...</span>     <span class="k">print</span><span class="p">(</span><span class="s">"%s - %s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">element</span><span class="p">.</span><span class="n">text</span><span class="p">))</span>
<span class="n">root</span> <span class="o">-</span> <span class="bp">None</span>
<span class="n">child</span> <span class="o">-</span> <span class="n">Child</span> <span class="mi">1</span>
<span class="n">child</span> <span class="o">-</span> <span class="n">Child</span> <span class="mi">2</span>
<span class="n">another</span> <span class="o">-</span> <span class="n">Child</span> <span class="mi">3</span>
</code></pre></div></div>

<p>如果只对单个标签感兴趣，则可以将其名称传递给<code class="language-plaintext highlighter-rouge">iter</code>以对其进行过滤。 从lxml 3.0开始，还可以传递多个标签来在迭代过程中拦截多个标签。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">root</span><span class="p">.</span><span class="nb">iter</span><span class="p">(</span><span class="s">"child"</span><span class="p">):</span>
<span class="p">...</span>     <span class="k">print</span><span class="p">(</span><span class="s">"%s - %s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">element</span><span class="p">.</span><span class="n">text</span><span class="p">))</span>
<span class="n">child</span> <span class="o">-</span> <span class="n">Child</span> <span class="mi">1</span>
<span class="n">child</span> <span class="o">-</span> <span class="n">Child</span> <span class="mi">2</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">root</span><span class="p">.</span><span class="nb">iter</span><span class="p">(</span><span class="s">"another"</span><span class="p">,</span> <span class="s">"child"</span><span class="p">):</span>
<span class="p">...</span>     <span class="k">print</span><span class="p">(</span><span class="s">"%s - %s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">element</span><span class="p">.</span><span class="n">text</span><span class="p">))</span>
<span class="n">child</span> <span class="o">-</span> <span class="n">Child</span> <span class="mi">1</span>
<span class="n">child</span> <span class="o">-</span> <span class="n">Child</span> <span class="mi">2</span>
<span class="n">another</span> <span class="o">-</span> <span class="n">Child</span> <span class="mi">3</span>
</code></pre></div></div>

<p>默认情况下，迭代会产生树中的所有节点，包括ProcessingInstructions，Comment和Entity实例。 如果要确保仅返回Element对象，则可以将Element作为标签参数传递：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">root</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">etree</span><span class="p">.</span><span class="n">Entity</span><span class="p">(</span><span class="s">"#234"</span><span class="p">))</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">root</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">etree</span><span class="p">.</span><span class="n">Comment</span><span class="p">(</span><span class="s">"some comment"</span><span class="p">))</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">root</span><span class="p">.</span><span class="nb">iter</span><span class="p">():</span>
<span class="p">...</span>     <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="n">tag</span><span class="p">,</span> <span class="nb">basestring</span><span class="p">):</span>  <span class="c1"># or 'str' in Python 3
</span><span class="p">...</span>         <span class="k">print</span><span class="p">(</span><span class="s">"%s - %s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">element</span><span class="p">.</span><span class="n">text</span><span class="p">))</span>
<span class="p">...</span>     <span class="k">else</span><span class="p">:</span>
<span class="p">...</span>         <span class="k">print</span><span class="p">(</span><span class="s">"SPECIAL: %s - %s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">element</span><span class="p">,</span> <span class="n">element</span><span class="p">.</span><span class="n">text</span><span class="p">))</span>
<span class="n">root</span> <span class="o">-</span> <span class="bp">None</span>
<span class="n">child</span> <span class="o">-</span> <span class="n">Child</span> <span class="mi">1</span>
<span class="n">child</span> <span class="o">-</span> <span class="n">Child</span> <span class="mi">2</span>
<span class="n">another</span> <span class="o">-</span> <span class="n">Child</span> <span class="mi">3</span>
<span class="n">SPECIAL</span><span class="p">:</span> <span class="o">&amp;</span><span class="c1">#234; - &amp;#234;
</span><span class="n">SPECIAL</span><span class="p">:</span> <span class="o">&lt;</span><span class="err">!</span><span class="o">--</span><span class="n">some</span> <span class="n">comment</span><span class="o">--&gt;</span> <span class="o">-</span> <span class="n">some</span> <span class="n">comment</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">root</span><span class="p">.</span><span class="nb">iter</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="n">etree</span><span class="p">.</span><span class="n">Element</span><span class="p">):</span>
<span class="p">...</span>     <span class="k">print</span><span class="p">(</span><span class="s">"%s - %s"</span> <span class="o">%</span> <span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="n">tag</span><span class="p">,</span> <span class="n">element</span><span class="p">.</span><span class="n">text</span><span class="p">))</span>
<span class="n">root</span> <span class="o">-</span> <span class="bp">None</span>
<span class="n">child</span> <span class="o">-</span> <span class="n">Child</span> <span class="mi">1</span>
<span class="n">child</span> <span class="o">-</span> <span class="n">Child</span> <span class="mi">2</span>
<span class="n">another</span> <span class="o">-</span> <span class="n">Child</span> <span class="mi">3</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">for</span> <span class="n">element</span> <span class="ow">in</span> <span class="n">root</span><span class="p">.</span><span class="nb">iter</span><span class="p">(</span><span class="n">tag</span><span class="o">=</span><span class="n">etree</span><span class="p">.</span><span class="n">Entity</span><span class="p">):</span>
<span class="p">...</span>     <span class="k">print</span><span class="p">(</span><span class="n">element</span><span class="p">.</span><span class="n">text</span><span class="p">)</span>
<span class="o">&amp;</span><span class="c1">#234;
</span></code></pre></div></div>

<p>传递通配符“ *”标记名称也将产生所有Element节点（且仅元素）。</p>

<p>在lxml.etree中，元素为树中的所有方向提供了进一步的迭代器：子代，父代（或更确切地说是祖先）和兄弟姐妹。</p>

<h2 id="serialisation">Serialisation</h2>

<p>序列化通常使用<code class="language-plaintext highlighter-rouge">tostring</code>函数来返回字符串，或者使用<code class="language-plaintext highlighter-rouge">ElementTree.write</code>方法来写入文件，类似文件的对象或URL（通过FTP PUT或HTTP POST）。 这两个调用都接受相同的关键字参数，例如<code class="language-plaintext highlighter-rouge">pretty_print</code>，用于格式化输出或编码，以选择除纯ASCII之外的特定输出编码：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">XML</span><span class="p">(</span><span class="s">'&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;'</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="s">b'&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">xml_declaration</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="s">b"&lt;?xml version='1.0' encoding='ASCII'?&gt;</span><span class="se">\n</span><span class="s">&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;"</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">encoding</span><span class="o">=</span><span class="s">'iso-8859-1'</span><span class="p">))</span>
<span class="s">b"&lt;?xml version='1.0' encoding='iso-8859-1'?&gt;</span><span class="se">\n</span><span class="s">&lt;root&gt;&lt;a&gt;&lt;b/&gt;&lt;/a&gt;&lt;/root&gt;"</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span><span class="n">pretty_print</span><span class="o">=</span><span class="bp">True</span><span class="p">).</span><span class="n">decode</span><span class="p">())</span>
<span class="o">&lt;</span><span class="n">root</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">b</span><span class="o">/&gt;</span>
  <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">root</span><span class="o">&gt;</span>

</code></pre></div></div>

<p>请注意，pretty print 将在末尾添加换行符。</p>

<p>为了对精美打印进行更细粒度的控制，您可以使用<code class="language-plaintext highlighter-rouge">indent</code>函数（在lxml 4.5中添加）在对树进行序列化之前向其添加空格缩进：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">XML</span><span class="p">(</span><span class="s">'&lt;root&gt;&lt;a&gt;&lt;b/&gt;</span><span class="se">\n</span><span class="s">&lt;/a&gt;&lt;/root&gt;'</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">).</span><span class="n">decode</span><span class="p">())</span>
<span class="o">&lt;</span><span class="n">root</span><span class="o">&gt;&lt;</span><span class="n">a</span><span class="o">&gt;&lt;</span><span class="n">b</span><span class="o">/&gt;</span>
<span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;&lt;/</span><span class="n">root</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">indent</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">).</span><span class="n">decode</span><span class="p">())</span>
<span class="o">&lt;</span><span class="n">root</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">b</span><span class="o">/&gt;</span>
  <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">root</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">root</span><span class="p">.</span><span class="n">text</span>
<span class="s">'</span><span class="se">\n</span><span class="s">  '</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">root</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">text</span>
<span class="s">'</span><span class="se">\n</span><span class="s">    '</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">indent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="s">"    "</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">).</span><span class="n">decode</span><span class="p">())</span>
<span class="o">&lt;</span><span class="n">root</span><span class="o">&gt;</span>
    <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">b</span><span class="o">/&gt;</span>
    <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">root</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">indent</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">space</span><span class="o">=</span><span class="s">"</span><span class="se">\t</span><span class="s">"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">).</span><span class="n">decode</span><span class="p">())</span>
<span class="o">&lt;</span><span class="n">root</span><span class="o">&gt;</span>
        <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span>
                <span class="o">&lt;</span><span class="n">b</span><span class="o">/&gt;</span>
        <span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">root</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>在lxml 2.0和更高版本（以及ElementTree 1.3）中，序列化功能可以完成比XML序列化更多的工作。 您可以通过传递方法关键字来序列化为HTML或提取文本内容：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">XML</span><span class="p">(</span>
<span class="p">...</span>    <span class="s">'&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Hello&lt;br/&gt;World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span> <span class="c1"># default: method = 'xml'
</span><span class="s">b'&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Hello&lt;br/&gt;World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">'xml'</span><span class="p">)</span> <span class="c1"># same as above
</span><span class="s">b'&lt;html&gt;&lt;head/&gt;&lt;body&gt;&lt;p&gt;Hello&lt;br/&gt;World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">'html'</span><span class="p">)</span>
<span class="s">b'&lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt;&lt;p&gt;Hello&lt;br&gt;World&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">'html'</span><span class="p">,</span> <span class="n">pretty_print</span><span class="o">=</span><span class="bp">True</span><span class="p">))</span>
<span class="o">&lt;</span><span class="n">html</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">head</span><span class="o">&gt;&lt;/</span><span class="n">head</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">body</span><span class="o">&gt;&lt;</span><span class="n">p</span><span class="o">&gt;</span><span class="n">Hello</span><span class="o">&lt;</span><span class="n">br</span><span class="o">&gt;</span><span class="n">World</span><span class="o">&lt;/</span><span class="n">p</span><span class="o">&gt;&lt;/</span><span class="n">body</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">html</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">'text'</span><span class="p">)</span>
<span class="s">b'HelloWorld'</span>
</code></pre></div></div>

<p>对于XML序列化，纯文本序列化的默认编码为ASCII：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">br</span> <span class="o">=</span> <span class="nb">next</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="nb">iter</span><span class="p">(</span><span class="s">'br'</span><span class="p">))</span>  <span class="c1"># get first result of iteration
</span><span class="o">&gt;&gt;&gt;</span> <span class="n">br</span><span class="p">.</span><span class="n">tail</span> <span class="o">=</span> <span class="s">u'W</span><span class="se">\xf6</span><span class="s">rld'</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">'text'</span><span class="p">)</span>  <span class="c1"># doctest: +ELLIPSIS
</span><span class="n">Traceback</span> <span class="p">(</span><span class="n">most</span> <span class="n">recent</span> <span class="n">call</span> <span class="n">last</span><span class="p">):</span>
  <span class="p">...</span>
<span class="nb">UnicodeEncodeError</span><span class="p">:</span> <span class="s">'ascii'</span> <span class="n">codec</span> <span class="n">can</span><span class="s">'t encode character u'</span>\<span class="n">xf6</span><span class="s">' ...

&gt;&gt;&gt; etree.tostring(root, method='</span><span class="n">text</span><span class="s">', encoding="UTF-8")
b'</span><span class="n">HelloW</span>\<span class="n">xc3</span>\<span class="n">xb6rld</span><span class="s">'
</span></code></pre></div></div>

<p>在这里，序列化为Python unicode字符串而不是字节字符串可能会很方便。 只需传递名称“ unicode”作为编码即可：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="n">encoding</span><span class="o">=</span><span class="s">'unicode'</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s">'text'</span><span class="p">)</span>
<span class="s">u'HelloW</span><span class="se">\xf6</span><span class="s">rld'</span>
</code></pre></div></div>

<h1 id="the-elementtree-class">The ElementTree class</h1>

<p><code class="language-plaintext highlighter-rouge">ElementTree</code>主要是围绕带有根节点的树的文档包装器。 它提供了两种用于序列化和常规文档处理的方法。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">XML</span><span class="p">(</span><span class="s">'''</span><span class="se">\
</span><span class="s">... &lt;?xml version="1.0"?&gt;
... &lt;!DOCTYPE root SYSTEM "test" [ &lt;!ENTITY tasty "parsnips"&gt; ]&gt;
... &lt;root&gt;
...   &lt;a&gt;&amp;tasty;&lt;/a&gt;
... &lt;/root&gt;
... '''</span><span class="p">)</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">ElementTree</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="n">docinfo</span><span class="p">.</span><span class="n">xml_version</span><span class="p">)</span>
<span class="mf">1.0</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="n">docinfo</span><span class="p">.</span><span class="n">doctype</span><span class="p">)</span>
<span class="o">&lt;</span><span class="err">!</span><span class="n">DOCTYPE</span> <span class="n">root</span> <span class="n">SYSTEM</span> <span class="s">"test"</span><span class="o">&gt;</span>

<span class="o">&gt;&gt;&gt;</span> <span class="n">tree</span><span class="p">.</span><span class="n">docinfo</span><span class="p">.</span><span class="n">public_id</span> <span class="o">=</span> <span class="s">'-//W3C//DTD XHTML 1.0 Transitional//EN'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tree</span><span class="p">.</span><span class="n">docinfo</span><span class="p">.</span><span class="n">system_url</span> <span class="o">=</span> <span class="s">'file://local.dtd'</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="n">docinfo</span><span class="p">.</span><span class="n">doctype</span><span class="p">)</span>
<span class="o">&lt;</span><span class="err">!</span><span class="n">DOCTYPE</span> <span class="n">root</span> <span class="n">PUBLIC</span> <span class="s">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span> <span class="s">"file://local.dtd"</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>当调用<code class="language-plaintext highlighter-rouge">parse</code>函数来解析文件或类似文件的对象时，也会得到ElementTree的收获（请参阅下面的解析部分）。</p>

<p>重要的区别之一是ElementTree类序列化为一个完整的文档，而不是单个Element。 这包括顶级处理说明和注释，以及文档中的DOCTYPE和其他DTD内容：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">tree</span><span class="p">).</span><span class="n">decode</span><span class="p">())</span>  <span class="c1"># lxml 1.3.4 and later
</span><span class="o">&lt;</span><span class="err">!</span><span class="n">DOCTYPE</span> <span class="n">root</span> <span class="n">PUBLIC</span> <span class="s">"-//W3C//DTD XHTML 1.0 Transitional//EN"</span> <span class="s">"file://local.dtd"</span> <span class="p">[</span>
<span class="o">&lt;</span><span class="err">!</span><span class="n">ENTITY</span> <span class="n">tasty</span> <span class="s">"parsnips"</span><span class="o">&gt;</span>
<span class="p">]</span><span class="o">&gt;</span>
<span class="o">&lt;</span><span class="n">root</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="n">parsnips</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">root</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>在原始的xml.etree.ElementTree实现中以及在lxml直到1.3.3中，输出看起来与仅序列化根Element时的输出相同：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">tree</span><span class="p">.</span><span class="n">getroot</span><span class="p">()).</span><span class="n">decode</span><span class="p">())</span>
<span class="o">&lt;</span><span class="n">root</span><span class="o">&gt;</span>
  <span class="o">&lt;</span><span class="n">a</span><span class="o">&gt;</span><span class="n">parsnips</span><span class="o">&lt;/</span><span class="n">a</span><span class="o">&gt;</span>
<span class="o">&lt;/</span><span class="n">root</span><span class="o">&gt;</span>
</code></pre></div></div>

<p>在lxml 1.3.4中，此序列化行为已更改。 之前，该树已序列化而没有DTD内容，这使lxml在输入输出循环中丢失了DTD信息。</p>

<h1 id="parsing-from-strings-and-files">Parsing from strings and files</h1>

<p>lxml.etree支持通过多种方式从所有重要来源（即字符串，文件，URL（http / ftp）和类似文件的对象）解析XML。 主要的解析函数是<code class="language-plaintext highlighter-rouge">fromstring</code>和<code class="language-plaintext highlighter-rouge">parse</code>，两者均以源作为第一个参数进行调用。 默认情况下，它们使用标准解析器，但是始终可以将其他解析器作为第二个参数传递。</p>

<h2 id="the-fromstring-function">The fromstring() function</h2>

<p><code class="language-plaintext highlighter-rouge">fromstring</code>函数是解析字符串的最简单方法：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">some_xml_data</span> <span class="o">=</span> <span class="s">"&lt;root&gt;data&lt;/root&gt;"</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">fromstring</span><span class="p">(</span><span class="n">some_xml_data</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">tag</span><span class="p">)</span>
<span class="n">root</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="s">b'&lt;root&gt;data&lt;/root&gt;'</span>
</code></pre></div></div>

<h2 id="the-xml-function">The XML() function</h2>

<p><code class="language-plaintext highlighter-rouge">XML</code>函数的行为类似于<code class="language-plaintext highlighter-rouge">fromstring</code>函数，但通常用于将XML文字直接写入源代码：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">XML</span><span class="p">(</span><span class="s">"&lt;root&gt;data&lt;/root&gt;"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">tag</span><span class="p">)</span>
<span class="n">root</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="s">b'&lt;root&gt;data&lt;/root&gt;'</span>
</code></pre></div></div>

<p>还有一个用于HTML文字的相应函数<code class="language-plaintext highlighter-rouge">HTML</code>。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">HTML</span><span class="p">(</span><span class="s">"&lt;p&gt;data&lt;/p&gt;"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="s">b'&lt;html&gt;&lt;body&gt;&lt;p&gt;data&lt;/p&gt;&lt;/body&gt;&lt;/html&gt;'</span>
</code></pre></div></div>

<h2 id="the-parse-function">The parse() function</h2>

<p><code class="language-plaintext highlighter-rouge">parse</code>函数用于从文件和类似文件的对象中进行解析。</p>

<p>作为此类文件状对象的示例，以下代码使用BytesIO类从字符串而不是外部文件读取。 该类来自Python 2.6和更高版本中的io模块。 在较旧的Python版本中，必须使用StringIO模块中的StringIO类。 但是，在现实生活中，您显然会避免同时执行所有操作，而使用上面的字符串解析函数。</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">BytesIO</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">some_file_or_file_like_object</span> <span class="o">=</span> <span class="n">BytesIO</span><span class="p">(</span><span class="s">b"&lt;root&gt;data&lt;/root&gt;"</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">tree</span> <span class="o">=</span> <span class="n">etree</span><span class="p">.</span><span class="n">parse</span><span class="p">(</span><span class="n">some_file_or_file_like_object</span><span class="p">)</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">tree</span><span class="p">)</span>
<span class="s">b'&lt;root&gt;data&lt;/root&gt;'</span>
</code></pre></div></div>

<p>请注意，由于字符串解析器的功能，<code class="language-plaintext highlighter-rouge">parse</code>返回的是ElementTree对象，而不是Element对象：</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="o">&gt;&gt;&gt;</span> <span class="n">root</span> <span class="o">=</span> <span class="n">tree</span><span class="p">.</span><span class="n">getroot</span><span class="p">()</span>
<span class="o">&gt;&gt;&gt;</span> <span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="p">.</span><span class="n">tag</span><span class="p">)</span>
<span class="n">root</span>
<span class="o">&gt;&gt;&gt;</span> <span class="n">etree</span><span class="p">.</span><span class="n">tostring</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
<span class="s">b'&lt;root&gt;data&lt;/root&gt;'</span>
</code></pre></div></div>

<p>这种差异背后的原因是<code class="language-plaintext highlighter-rouge">parse</code>从文件返回完整的文档，而字符串解析函数通常用于解析XML片段。</p>

<p><code class="language-plaintext highlighter-rouge">parse</code>函数支持以下任何来源：</p>

<ul>
  <li>
    <p>一个打开的文件对象（确保以二进制模式打开它）</p>
  </li>
  <li>
    <p>一个类似文件的对象，它具有.read（byte_count）方法，每次调用都返回一个字节字符串</p>
  </li>
  <li>
    <p>文件名字符串</p>
  </li>
  <li>
    <p>HTTP或FTP URL字符串</p>
  </li>
</ul>

<p>请注意，传递文件名或URL通常比传递打开的文件或类似文件的对象更快。 但是，libxml2中的HTTP / FTP客户端非常简单，因此HTTP身份验证之类的事情需要专用的URL请求库，例如 urllib2或请求。 这些库通常提供类似文件的对象，供您在响应流入时从中解析结果。</p>

<h2 id="parser-objects">Parser objects</h2>

<p>以后内容省略，请参考文末给出链接</p>

<h1 id="reference">Reference</h1>

<p>https://lxml.de/tutorial.html</p>
